diff --git lib/mega.c lib/mega.c
index 432a02d..e8f733b 100644
--- lib/mega.c
+++ lib/mega.c
@@ -4224,7 +4224,6 @@ gboolean mega_session_download_data(struct mega_session *s, struct mega_download
 	gc_object_unref GFileIOStream *iostream = NULL;
 	gc_object_unref GFileOutputStream *ostream = NULL;
 	GSeekable* seekable = NULL;
-	gc_http_free struct http *h = NULL;
 	struct get_data_state state = { .s = s };
 	gc_free gchar *tmp_path = NULL, *file_path = NULL, *tmp_name = NULL;
 	guint64 download_from = 0;
@@ -4373,12 +4372,6 @@ gboolean mega_session_download_data(struct mega_session *s, struct mega_download
 
 	send_status(s, &status_data);
 
-	// perform download
-	h = http_new();
-	http_set_progress_callback(h, progress_dl, &state);
-	http_set_speed(h, s->max_ul, s->max_dl);
-	http_set_proxy(h, s->proxy);
-
 	// We'll download the file sequentially in 256MB increments (chunks),
 	// re-trying if a chunk fails. We will pre-encrypt and pre-calculate mac
 	// for the chunk so that we don't need to do it again when download
@@ -4403,12 +4396,20 @@ gboolean mega_session_download_data(struct mega_session *s, struct mega_download
 		state.mac_saved = state.mac;
 		guint tries = 0;
 		gboolean download_ok;
+		struct http *h;
 		gc_free gchar *url = g_strdup_printf("%s/%" G_GUINT64_FORMAT "-%" G_GUINT64_FORMAT,
 						     params->download_url,
 						     from, to - 1);
 
 retry:
+		// perform download
+		h = http_new();
+		http_set_progress_callback(h, progress_dl, &state);
+		http_set_speed(h, s->max_ul, s->max_dl);
+		http_set_proxy(h, s->proxy);
 		download_ok = http_post_stream_download(h, url, get_data_cb, &state, &local_err);
+		http_free(h);
+
 		if (!download_ok) {
 			// try 3 times at most (we only retry if we can seek the stream)
 			tries++;
